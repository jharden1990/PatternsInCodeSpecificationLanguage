wrong_list_length_8_2():
    Old Code:
        def wrong_list_length_8_2():
            message = "You must have at least three pieces"
            code = "list length_8.2"
            tldr = "List too short"
            matches = find_matches("_list_ = __expr__")
            if matches:
                for match in matches:
                    __expr__ = match["__expr__"]
                    if __expr__.ast_name == "List" and len(__expr__.elts) < 3:
                        return explain_r(message, code, label=tldr)
            return False
    New Code 1:
        MESSAGE "You must have at least three items in your list."
        ERROR_CODE "list length 8.2"
        TLDR "List too short"
        MATCH "_list_ = __expr__"
        	expr = "__expr__"
        	IF expr IS LIST AND Length(expr) < 3
        		GIVE FEEDBACK
    New Code 2:
        MESSAGE "You must have at least three items in your list."
        ERROR_CODE "list length 8.2"
        TLDR "List too short"
        MATCH "___ = __expr__"
        WHERE type("__expr__") == LIST AND length("__expr__") < 3
            GIVE FEEDBACK
missing_list_initialization_8_2():
    Old Code:
        message = ('You must set the variable <code>shopping_cart</code>'
                   'to a list containing the prices of items in the shopping cart.')
        code = "missing_list_init_8.2"
        tldr = "Missing list initialization"
        matches = find_matches("shopping_cart = __expr__")
        for match in matches:
            __expr__ = match["__expr__"]
            if __expr__.ast_name == "List":
                return False
        return explain_r(message, code, label=tldr)
    New Code 1:
        MESSAGE
        ERROR_CODE
        TLDR
        MATCH "shopping_cart = __expr__"
            expr = "__expr__"
            IF expr IS LIST
                GIVE NO FEEDBACK
    New Code 2:
        MESSAGE
        ERROR_CODE
        TLDR
        MATCH "shopping_cart = __expr__"
        WHERE type("__expr__") == LIST
            GIVE NO FEEDBACK
wrong_list_is_constant_8_2():
    Old Code:
        message = 'You must set <code>shoppping_cart</code> to a list of values not to a single number.'
        code = "list_is_const_8.2"
        tldr = "Shopping Cart not set to list"
        matches = find_matches("shopping_cart = __expr__")
        for match in matches:
            __expr__ = match["__expr__"]
            if __expr__.ast_name == "Num":
                return explain_r(message, code, label=tldr)
        return False
    New Code 1:
        MESSAGE
        ERROR_CODE
        TLDR
        MATCH "shopping_cart = __expr__"
            expr = "__expr__"
            IF expr IS NUM
                GIVE FEEDBACK
    New Code 2:
        MESSAGE
        ERROR_CODE
        TLDR
        MATCH "shopping_cart = __expr__"
        WHERE type("__expr__") == NUM
            GIVE FEEDBACK
list_all_zeros_8_2(): (NOT DONE)
    Old Code:
        message = 'Try seeing what happens when you change the numbers in the list.'
        code = 'default_list_8.2'
        tldr = 'Use different numbers'
        matches = find_matches("_var_ = [__list__]")
        for match in matches:
            __list__ = match['__list__']
            list_node = __list__.parent
            all_num = list_node.find_all("Num")
            all_zeros = True
            for num in all_num:
                if num.n != 0:
                    all_zeros = False
                    break
            if all_zeros:
                return explain_r(message, code, label=tldr)
        return False
    New Code 1:
        MESSAGE
        ERROR_CODE
        TLDR
        MATCH "_var_ = [__list__]"
            GET "__list__"
            ...
    New Code 2:
        MESSAGE
        ERROR_CODE
        TLDR

    IMPORTANT Concerns:
        Can the above pattern be used with anything besides a list? Assuming for the moment that the answer is effectively no, it should not be used for anything beyond a list at the level we are working at.
        Also, what if we want to give different feedback based on the results of a single test's execution instead of making multiple, similar tests?
wrong_list_initialization_placement_8_3()
    Old Code:
        message = ('The list of episode lengths (<code>episode_length_list</code>)'
                   ' must be initialized before the iteration which uses this list.')
        code = "init_place_8.3"
        tldr = "Wrong Initialization Placement"
        for_matches = find_matches("for ___ in ___:\n"
                                   "    pass")
        init_matches = find_matches("episode_length_list = ___")
        if init_matches and for_matches:
            for for_match in for_matches:
                for_lineno = for_match.match_lineno
                for init_match in init_matches:
                    if init_match.match_lineno > for_lineno:
                        return explain_r(message, code, label=tldr)
        return False
    New Code 1:
        MESSAGE
        ERROR_CODE
        TLDR
        MATCH "for ___ in ___:\n    pass"
            lineNum = LINENUM("for ___ in ___:\n    pass")
            MATCH "episode_length_list = ___"
                lineNum2 = LINENUM("episode_length_list = ___")
                IF lineNum < lineNum2
                    GIVE FEEDBACK

    New Code 1.1 (would this work as well?):
        MESSAGE
        ERROR_CODE
        TLDR
        MATCH "for ___ in ___:\n    __expr__"


    New Code 2.1:
        MESSAGE
        ERROR_CODE
        TLDR
        MATCH "for ___ in ___:\n    __expr__"
        WHERE "__expr__" == "episode_length_list = ___"
        GIVE FEEDBACK

wrong_accumulator_initialization_placement_8_3()
- see wrong_list_initialization_placement_8_3()

wrong_iteration_body_8_3()
    Old Code:
        message = "The addition of each episode length to the total length is not in the correct place."
        code = "iter_body_8.3"
        tldr = "Accumulation Misplaced"
        match = find_match("for _item_ in _list_:\n"
                           "    sum_length = ___ + ___\n")
        if not match:
            return explain_r(message, code, label=tldr)
        return False
    New Code 1:
    New Code 2:
        MESSAGE:
        ERROR_CODE:
        TLDR:
        CODE:
        MATCH "for _item_ in _list_:\n    sum_length = ___ + ___\n"
        ## IMPORTANT QUESTION: ASK about removing the double-line part?
            GIVE NO FEEDBACK

wrong_print_8_3()
    Old Code:
        message = ('The output of the total length of time is not in the correct place. The total length of time should be'
               ' output only once after the total length of time has been computed.')
        code = "print_8.3"
        tldr = "Print statement misplaced"
        match = find_match("for _item_ in _list_:\n"
                           "    pass\n"
                           "print(_total_)")
        if not match:
            return explain_r(message, code, label=tldr)
        return False
    New Code 1:
    New Code 2:
        MESSAGE...
        CODE:
        MATCH "for _item_ in _list_:\n"
                           "    pass\n"
                           "print(_total_)"
            GIVE NO FEEDBACK

missing_target_slot_empty_8_4()
    Old Code:
        message = 'You must fill in the empty slot in the iteration.'
        code = 'target_empty_8.4'
        tldr = "Iteration Variable Empty"
        matches = find_matches("for _item_ in pages_count_list:\n"
                               "    pass")
        if matches:
            for match in matches:
                _item_ = match["_item_"][0]
                if _item_.id == "___":
                    return explain_r(message, code, tldr)
        return False
    New Code 1:
        MATCH "for _item_ in pages_count_list:\n"
                               "    pass"
            item = "_item_".first()
            IF item == "___"
                GIVE FEEDBACK
    New Code 2:
        MATCH "for _item_ in pages_count_list:\n"
                               "    pass"
        WHERE "_item_".first() == "___"
            GIVE FEEDBACK

missing_addition_slot_empty_8_4()
    - see missing_target_slot_empty_8_4()

wrong_names_not_agree_8_4()
    Old Code:
        message = "Each value of <code>{0!s}</code> must be added to <code>{1!s}</code>."
        code = "name_agree_8.4"
        tldr = "Iteration Variable and Accumulation Mismatch"
        matches = find_matches("for _item1_ in pages_count_list:\n"
                               "    sum_pages = sum_pages + _item2_")
        if matches:
            for match in matches:
                # in theory, these will always be different? should test in test_cait
                _item1_ = match["_item1_"][0]
                _item2_ = match["_item2_"][0]
                if _item1_.id != _item2_.id:
                    return explain_r(message.format(_item1_.id, _item2_.id), code, label=tldr)
        return False
    New Code 2:
        MATCH "for _item1_ in pages_count_list:\n"
                "    sum_pages = sum_pages + _item2_"
        WHERE "_item1_".first().id != "_item2_".first().id
            GIVE FEEDBACK

wrong_modifying_list_8_5()
    New Code 1:
    New Code 2:
    MATCH "[20473, 27630, 17849, 19032, 16378]"
        GIVE NO FEEDBACK

wrong_modifying_list_8_6()
    - see wrong_modifying_list_8_5()

wrong_should_be_counting()
    Old Code:
        message = "This problem asks for the number of items in the list not the total of all the values in the list."
        code = "not_count"
        tldr = "Summing instead of counting"
        matches = find_matches("for _item_ in ___:\n"
                               "    __expr__")
        if matches:
            for match in matches:
                _item_ = match["_item_"][0]
                __expr__ = match["__expr__"]
                submatches = __expr__.find_matches("___ = ___ + _item_")
                if submatches:
                    return explain_r(message, code, label=tldr)
        return False
    New Code 1:
        MATCH "for _item_ in ___:\n"
                               "    __expr__"
    New Code 2:
        MATCH "for _item_ in ___:\n"
                               "    __expr__"
            WITHIN "__expr__" MATCH "___ = ___ + _item_"
                GIVE FEEDBACK
    Concerns:
        Is it possible to link _item_ in the first match with _item_ in the second match automatically? Is it worth it to do so? If no to either of these questions, how to change it?
            IMPORTANT NOTE: It appears that CAIT already does this in the old code???? Need to check with Luke on this...

wrong_should_be_summing()
    - see wrong_should_be_counting()

missing_addition_slot_empty()
    - see missing_addition_slot_empty_8_4()

wrong_cannot_sum_list()
    Old Code:
        message = 'Addition can only be done with a single value at a time, not with an entire list at one'
        code = "sum_list"
        tldr = "Cannot Sum a List"
        matches = find_matches("for ___ in _list_ :\n"
                               "    __expr__")
        if matches:
            for match in matches:
                _list_ = match["_list_"][0] ##IMPORTANT NOTE: IS THIS LINE RELEVANT ANYMORE?
                __expr__ = match["__expr__"]
                # submatches = __expr__.find_matches("___ = ___ + {}".format(_list_.id), )
                submatches = __expr__.find_matches("___ = ___ + _list_")
                if submatches:
                    return explain_r(message, code, label=tldr)
        return False
    New Code 1:
    New Code 2:
        MATCH "for ___ in _list_ :\n"
                               "    __expr__"
            WITHIN "__expr__" MATCH "___ = ___ + _list_"
                GIVE FEEDBACK
    Concerns:
        Is it possible to link _item_ in the first match with _item_ in the second match automatically? Is it worth it to do so? If no to either of these questions, how to change it?
            IMPORTANT NOTE: It appears that CAIT already does this in the old code???? Need to check with Luke on this...

missing_no_print()
    MATCH "print(___)" WITH CUT=TRUE
        GIVE NO FEEDBACK

missing_counting_list()
    Old Code:
        message = 'Count the total number of items in the list using iteration.'
        code = "miss_count_list"
        tldr = "Missing Count in Iteration"
        matches = find_matches("for _item_ in ___:\n"
                               "    __expr__")
        if matches:
            for match in matches:
                __expr__ = match["__expr__"]
                submatches = __expr__.find_matches("_sum_ = _sum_ + 1", ) 
                ## IMPORTANT NOTE: purpose of comma here above?????
                if submatches:
                    return False
        return explain_r(message, code, label=tldr)
    New Code 2:
        MATCH "for _item_ in ___:\n"
                               "    __expr__"
            WITHIN "__expr__" MATCH "_sum_ = _sum_ + 1"
                GIVE NO FEEDBACK

missing_summing_list()
    - see missing_counting_list()

missing_zero_initialization()
    Old Code:
        message = ('The addition on the first iteration step is not correct because either the variable <code>{0!s}</code> '
               'has not been initialized to an appropriate initial value '
               'or it has not been placed in an appropriate location')
        code = "miss_zero_init"
        tldr = "Missing Initialization for Accumulator"
        matches01 = find_matches("for ___ in ___:\n"
                                 "    __expr__")
        if matches01:
            for match01 in matches01:
                __expr__ = match01["__expr__"]
                submatches01 = __expr__.find_matches("_sum_ = _sum_ + ___", )
                ## IMPORTANT NOTE: again, purpose of comma here above?
                if submatches01:
                    for submatch01 in submatches01:
                        _sum_ = submatch01["_sum_"][0]
                        matches02 = find_matches(("{} = 0\n"
                                                  "for ___ in ___:\n"
                                                  "    __expr__").format(_sum_.id))
                        if not matches02:
                            return explain_r(message.format(_sum_.id), code, label=tldr)
        return False
    New Code 1:
    New Code 2:
        MATCH "for ___ in ___:\n"
                                 "    __expr__"
            WITHIN "__expr__" MATCH "_sum_ = _sum_ + ___"
                MATCH "_sum_ = 0\n"
                                                  "for ___ in ___:\n"
                                                  "    __expr__"
                    GIVE NO FEEDBACK
    New Code 2.1:
        MATCH "for ___ in ___:\n"
                                 "    __expr__"
            WITHIN "__expr__" MATCH "_sum_ = _sum_ + ___"
                MATCH "_sum_ = 0"
                WHERE lineNum("_sum_ = 0") > lineNum("for ___ in ___:\n"
                                 "    __expr__")
                    GIVE NO FEEDBACK                    

    IMPORTANT Concerns:
        This problem could be done differently, such as with lineNum function, right? Assuming so, use New Code 2.1. But what if they initialize the sum variable after 1 for loop and before the summation loop? Maybe that's why the above is used???
        If using New Code 2, does it work if we just put it the way we did, or do we have to use .format(_sum_.id)?
        Concerned that New Code 2.1 will not work... need to review whether my method of "GIVE (NO) FEEDBACK" actually works... concern is that a problem may not want to default to "Return false" on the first instance of not finding something...
            Could have giveFeedback be a variable set to false (or true) at the beginning of each problem and modified as necessary.

wrong_printing_list()
    New Code 2:
        MATCH "for ___ in ___:\n"
                           "    __expr__"
            WITHIN "__expr__" MATCH "print(___)"
                GIVE FEEDBACK

missing_average()
    Old Code:
        message = "An average value is not computed.<"
        code = "no_avg"
        tldr = "Missing Computation"
        matches_missing = find_matches("for ___ in ___:\n"
                                       "    pass\n"
                                       "__expr__")
        matches = []
        if matches_missing:
            for match in matches_missing:
                __expr__ = match["__expr__"]
                sub_matches = __expr__.find_matches("_total_/_count_", )
                if sub_matches:
                    for sub_match in sub_matches:
                        _total_ = sub_match["_total_"][0]
                        _count_ = sub_match["_count_"][0]
                        if _total_.id != _count_.id:
                            matches.append(match)
        if not len(matches) > 0:
            return explain_r(message, code, label=tldr)
        return False
    New Code 2:
        MATCH "for ___ in ___:\n"
                                       "    pass\n"
                                       "__expr__"
            WITHIN "__expr__" MATCH "_total_/_count_" WHERE "_total_".first().id != "_count_".first().id
                GIVE NO FEEDBACK

wrong_average_denominator()
    - IMPORTANT: need help on this one due to find_expr_sub_matches() function


wrong_average_numerator()
    - easy enough

wrong_compare_list()
    - IMPORTANT: need to know more about .has function

wrong_for_inside_if()
    - easy enough

iterator_is_function()
    - IMPORTANT: need help understanding the code here...

wrong_list_initialization_9_1()
    - easy enough

wrong_accumulator_initialization_9_1()
    - easy enough

wrong_accumulation_9_1()
    - easy enough

wrong_list_initialization_placement_9_1()
    - easy enough

wrong_accumulator_initialization_placement_9_1()
    - easy enough

wrong_iteration_body_9_1()
    - easy enough

wrong_print_9_1()
    - easy enough

wrong_iteration_body_9_2()
    - IMPORTANT: need help with .numeric_logic_check() function

wrong_decision_body_9_2()
    - IMPORTANT: need help with .numeric_logic_check() function

wrong_comparison_9_6()
    - IMPORTANT: need help with .numeric_logic_check() function

wrong_filter_condition_10_3()
    - IMPORTANT: need help with .numeric_logic_check() function

wrong_and_filter_condition_10_4()
    - IMPORTANT: need help with .numeric_logic_check() function
    - IMPORTANT: need help with .has() function

wrong_nested_filter_condition_10_4()
    - IMPORTANT: need help with .numeric_logic_check() function
    - IMPORTANT: need help with .has() function

wrong_filter_problem_at11_10_5()
    - IMPORTANT: need help with .numeric_logic_check() function
    - IMPORTANT: need help with .has() function

wrong_filter_problem_at12_10_5()
    - IMPORTANT: need help with .numeric_logic_check() function
    - IMPORTANT: need help with .has() function

wrong_append_problem_at11_10_5()
    - IMPORTANT: need help with .numeric_logic_check() function
    - IMPORTANT: need help with .has() function

wrong_append_problem_at12_10_5()
    - IMPORTANT: need help with .numeric_logic_check() function
    - IMPORTANT: need help with .has() function

wrong_debug_10_6()
    Old Code:
        message = "This is not one of the two changes needed. Undo the change and try again."
        code = "debug_10.6"
        tldr = "At least one unnecessary change"
        matches = find_matches('quakes = earthquakes.get("depth","(None)","")\n'
                               'quakes_in_miles = []\n'
                               'for quake in _list1_:\n'
                               '    _list2_.append(quake * 0.62)\n'
                               'plt.hist(quakes_in_miles)\n'
                               'plt.xlabel("Depth in Miles")\n'
                               'plt.ylabel("Number of Earthquakes")\n'
                               'plt.title("Distribution of Depth in Miles of Earthquakes")\n'
                               'plt.show()')
        for match in matches:
            name1 = match["_list1_"][0].ast_node.id
            name2 = match["_list2_"][0].ast_node.id
            master_list = ["quake", "quakes", "quakes_in_miles"]
            if (name1 in master_list and name2 in master_list and
                    name1 != "quakes_in_miles" and name2 != "quakes" and
                    (name1 != "quake" or name2 != "quake")):
                return False
        return explain_r(message, code, label=tldr)
    - IMPORTANT: going to want to go over this with luke, specifically .ast_node.id

wrong_initialization_in_iteration()


plot_group_error()


all_labels_present()
    - IMPORTANT: difference between gently_r and explain_r?

hard_code_8_5()


REST NOT MENTIONED SHOULD BE DOABLE.