This document goes over the current code in instructor_iteration.py for Pedal as of 4-16-2020 and notes whether the current tests can be represented in the proposed specification language. See the Statistics below for more information.
Statistics:
    Date Success/Fail Documentation Updated: 4-20-2020
    Date Statistics Updated: 4-20-2020
    Overall Rate:
        SUCCESS: 9
        FAIL: 0
    Specific Rates:
        SUCCESS: 0
        SUCCESS WITH MINOR ASSUMPTIONS: 4
        SUCCESS WITH ASSUMPTIONS: 5
        FAIL: 0
def wrong_target_is_list(): SUCCESS WITH ASSUMPTIONS
    """

    Returns:

    """
    message = ('The variable <code>{0!s}</code> is a list and '
               'should not be placed in the iteration variable slot of the "for" block')
    code = "target_is_list"
    tldr = "Iteration Variable Overwriting List"
    match = find_match("for _item_ in ___:\n    pass")
    if match:
        _item_ = match["_item_"].astNode
        if data_state(_item_).was_type('list'):
            return explain(message.format(_item_.id), label=code, title=tldr)
    return False

    NEW CODE:
        FIND pattern1
        WHERE _item_ WAS OF TYPE LIST
        IF FOUND GIVE FEEDBACK
        FORMAT MESSAGE USING _item_.astNode.id

    NOTES ON NEW CODE:
        Assumes 2 things:
            1. Can get astNode of the _item_ (need to consider how to do this, as opposed to what appears to be the default way of fetching items (_item_ = match["_item_"][0]))
            2. Can represent data_state(_item_).was_type('list') in language
def wrong_list_repeated_in_for(): SUCCESS WITH ASSUMPTIONS
    """

    Returns:

    """
    message = 'The <code>{0!s}</code> variable can only appear once in the "for" block.'
    code = "list_repeat"
    tldr = "Duplicate Iteration Variable"
    match = find_match("for _item_ in _item_:\n    pass")
    if match:
        _item_ = match["_item_"].astNode
        if data_state(_item_).was_type('list'):
            return explain(message.format(_item_.id), label=code, title=tldr)
    return False

    NOTES ON NEW CODE:
        see wrong_target_is_list() for more info on assumptions.
def missing_iterator_initialization(): SUCCESS WITH ASSUMPTIONS
    """

    Returns:

    """
    message1 = "The slot to hold a list in the iteration is empty."
    code1 = "no_iter_init-blank"
    tldr1 = "Iteration Variable is Blank"

    message2 = "The variable <code>{0!s}</code> is in the list slot of the iteration but is not a list."
    code2 = "no_iter_init"
    tldr2 = "Iteration Variable is Not a List"

    match = find_match("for ___ in _list_:\n    pass")
    if match:
        _list_ = match["_list_"].astNode
        if _list_.id == "___":
            return explain(message1, label=code1, title=tldr1)
        elif not data_state(_list_).was_type('list'):
            return explain(message2.format(_list_.id), label=code2, title=tldr2)
    return False

    NEW CODE 1:
        FIND pattern1
        WHERE _list_.astNode.id == "___"
        IF FOUND GIVE FEEDBACK

        FIND pattern1
        WHERE _list_.astNode.id WAS NOT OF TYPE LIST
        IF FOUND GIVE FEEDBACK

    NEW CODE 2:
        MESSAGE `...`, `...`
        LABEL `...`, `...`
        TITLE `...`, `...`
        FIND pattern1
        WHERE _list_.astNode.id == "___"
        IF FOUND GIVE FEEDBACK([1,1,1])
        ELSE FIND pattern1
        WHERE _list_.astNode WAS OF TYPE LIST
        IF FOUND GIVE FEEDBACK([2,2,2])
def wrong_iterator_not_list(): SUCCESS WITH ASSUMPTIONS
    """

    Returns:

    """
    message = ("The variable <code>{0!s}</code> has been set to something that is not a list but is placed "
               "in the iteration block that must be a list.")
    code = "iter_not_list"
    tldr = "Iteration List is not list"

    match = find_match("for ___ in _item_:\n    pass")
    if match:
        _item_ = match["_item_"].astNode
        if not data_state(_item_).was_type('list'):
            return explain(message.format(_item_.id), label=code, title=tldr)
    return False

    NOTES ON NEW CODE:
        see wrong_target_is_list for assumptions.
def missing_target_slot_empty(): SUCCESS WITH MINOR ASSUMPTIONS
    """

    Returns:

    """
    message = "You must fill in the empty slot in the iteration."
    code = "target_empty"
    tldr = "Missing Iteration Variable"
    match = find_match("for _item_ in ___:\n    pass")
    if match:
        _item_ = match["_item_"].astNode
        if _item_.id == "___":
            return explain(message, label=code, title=tldr)
    return False

    NOTES ON NEW CODE:
        Simple FIND with IF FOUND, need to account for checking astNode of _item_, though.
def list_not_initialized_on_run(): SUCCESS WITH MINOR ASSUMPTIONS
    """

    Returns:

    """
    message = "The list in your for loop has not been initialized."
    code = "no_list_init"
    tldr = "List Variable Uninitialized"
    match = find_match("for ___ in _item_:\n    pass")
    if match:
        _item_ = match["_item_"][0].astNode
        if def_use_error(_item_):
            return explain(message, label=code, title=tldr)
    return False

    NEW CODE:
        FIND pattern1
        WHERE _item_ NOT INITIALIZED
        IF FOUND GIVE FEEDBACK

    NOTES:
        Assumes that NOT INITIALIZED corresponds to above code. Need to know more about what def_use_error does.
def list_initialization_misplaced(): SUCCESS WITH ASSUMPTIONS
    """

    Returns:

    """
    message = "Initialization of <code>{0!s}</code> is a list but either in the wrong place or redefined"
    code = "list_init_misplaced"
    tldr = "Iterating over Non-list"
    match = find_match("for ___ in _item_:\n    pass")
    if match:
        _item_ = match["_item_"][0].astNode
        if data_state(_item_).was_type('list') and def_use_error(_item_):
            return explain(message.format(_item_.id), label=code, title=tldr)
    return False

    NOTES ON NEW CODE:
        Need to know what def_use_error does. See wrong_target_is_list() for more info on other assumptions.
def missing_for_slot_empty(): SUCCESS WITH MINOR ASSUMPTIONS
    """

    Returns:

    """
    message = "You must fill in the empty slot in the iteration."
    code = "for_incomplete"
    tldr = "Iteration Incomplete"
    match = find_match("for _item_ in _list_:\n    pass")
    if match:
        _item_ = match["_item_"][0].astNode
        _list_ = match["_list_"][0].astNode
        if _item_.id == "___" or _list_.id == "___":
            return explain(message, label=code, title=tldr)
    return False

    NOTES ON NEW CODE:
        Assumes being able to fetch astNode of an item at a specific point? Need to talk with luke about this.
        Rest is just a simple FIND with IF FOUND.
def wrong_target_reassigned(): SUCCESS WITH MINOR ASSUMPTIONS
    """

    Returns:

    """
    message = "The variable <code>{0!s}</code> has been reassigned. The iteration variable shouldn't be reassigned"
    code = "target_reassign"
    tldr = "Iteration Variable has been Reassigned"
    matches = find_matches("for _item_ in ___:\n"
                           "   __expr__")
    for match in matches:
        __expr__ = match["__expr__"]
        _item_ = match["_item_"][0]
        submatches = __expr__.find_matches("_item_ = ___")
        if submatches:
            return explain(message.format(_item_), label=code, title=tldr)
    return False

    NEW CODE:
        FIND pattern
        WITHIN __expr__ FIND `_item_ = ___`
        IF FOUND GIVE FEEDBACK
        FORMAT MESSAGE USING _item_

    NEW CODE NOTES:
        assumes that _item_ from first pattern is _item_ from second pattern.