hard_coding(val_list)
	Old Code:
		message = ("Please show code that makes the computer extract "
	               "the value from the dictionary.")
	    code = "hard_code"
	    tldr = "Printing raw value"
	    # Pattern 1 possibility
	    matches = find_matches("print(__exp__)")
	    for match in matches:
	        __exp__ = match["__exp__"]
	        value = __exp__.value
	        if value in val_list:
	            return explain_r(message, code, label=tldr)

	    # Pattern 2 possibility
	    matches = find_matches("__exp__\n"
	                           "print(_var_)")
	    for match in matches:
	        __exp__ = match["__exp__"]
	        _var_ = match["_var_"]
	        submatches = __exp__.find_matches("_var_ = __exp2__")
	        for submatch in submatches:
	            __exp2__ = submatch["__exp2__"]
	            value = __exp2__.value
	            if value in val_list:
	                return explain_r(message, code, label=tldr)
	    return False
	New Code SQL:
		MESSAGE
		LABEL
		TITLE
		FIND "print(__exp__)"
		WHERE "__exp__".value IN val_list
		UNION/OR
		FIND "__exp__\n"
	                           "print(_var_)"
		WITHIN "__exp__" FIND "_var_ = __exp2__"
		WHERE/HAVING "__exp2__".value() IN val_list
		GIVE FEEDBACK


	Concern:
		IMPORTANT DESIGN CONSIDERATION: Should I split the two patterns into two different tests, or try to combine them into 1 test? It seems like I could at least give people the option of running multiple patterns in the same test.
		Also, WHERE again or HAVING?
		Finally, take quotes out of WHERE (and HAVING) clauses or no? Probably take them out.
		Should I use the word UNION, or should I use the word OR?

print_dict_key(keys)
	Old Code:
	    message = ('You\'ve printed the dictionary key <code>"{}"</code> instead of using an extracted value and '
	               'printing it. Use the Dictionary access syntax to print the value associated with a key')
	    code = "dict_k_print"
	    tldr = "Printing key, not value"
	    matches = find_matches("print(__str__)")
	    matches += find_matches("print([__str__])")

	    for match in matches:
	        __str__ = match["__str__"]
	        if __str__.is_ast("Str") and __str__.value in keys:
	            return explain_r(message.format(__str__.value), code, label=tldr)
	    return False
	New Code:
		MESSAGE
		LABEL
		TITLE
		FIND "print(__str__)"
		WHERE "__str__".is_ast("Str") AND "__str__".value IN keys
		GIVE FEEDBACK
		FORMAT MESSAGE USING "__str__".value

var_instead_of_key(keys)
	Old Code:
		message = ("It looks like you are trying to use (<code>{}</code>) as a dictionary key. "
	               "Use the dictionary access syntax to get values from a dictionary")
	    code = "var_as_k"
	    tldr = "Using Variable instead of key"
	    matches = find_matches("_var_")
	    matches += find_matches("[_var_]")
	    for match in matches:
	        _var_ = match["_var_"]
	        if _var_.id in keys:
	            submatch = find_match("_dict_['{}']".format(_var_.id))
	            if submatch is None:
	                return explain_r(message.format(_var_.id), code, label=tldr)
	    return False
	New Code SQL:
		FIND "_var_" OR "[_var_]"
		WHERE "_var_" IN keys
		WITHIN SOURCE_CODE FIND "_dict_['_var_']"
		GIVE NO FEEDBACK
		FORMAT MESSAGE USING "_var_".id 


def missing_key(keys):
    message = "You seem to be missing the following dictionary keys:<ul>{}</ul>"
    code = "miss_key"
    tldr = "Missing necessary keys"
    key_list = ""
    for key in keys:
        matches = find_matches("\"{}\"".format(key))
        if not matches:
            key_list += '<li><code>"' + key + '"</code></li>'
    if key_list != "":
        return explain_r(message.format(key_list), code, label=tldr)
    return False

    New Code:
    	PARAMETER keys_needed IN, keys_missing OUT
    	MESSAGE
    	LABEL
    	TITLE
    	FIND EACH `"{keys_needed}"` 
    	IF NOT FOUND ADD TO keys_missing
    	END
    	IF keys_missing IS NOT EMPTY
    	FORMAT MESSAGE USING keys_missing 

    New Code 2:
    	PARAMETER key1, key2
    	MESSAGE `... {}`
    	FIND `_var_[{key1}][{key2}]`
    	WHERE which_missing(key1, key2) IS NOT EMPTY
    	IF FOUND GIVE FEEDBACK
    	FORMAT MESSAGE USING which_missing(key1, key2)


def blank_key(keys):
    message = "You seem to be missing the following dictionary keys:<ul>{}</ul>"
    code = "blank_key"
    tldr = "Missing Key"
    key_list = ""

    for key in keys:
        if not find_match("_var_['{}']".format(key)):
            key_list += '<li><code>"' + key + '"</code></li>'

    if key_list != "":
        return explain_r(message.format(key_list), code, label=tldr)