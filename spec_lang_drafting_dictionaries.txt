hard_coding(val_list)
	Old Code:
		message = ("Please show code that makes the computer extract "
	               "the value from the dictionary.")
	    code = "hard_code"
	    tldr = "Printing raw value"
	    # Pattern 1 possibility
	    matches = find_matches("print(__exp__)")
	    for match in matches:
	        __exp__ = match["__exp__"]
	        value = __exp__.value
	        if value in val_list:
	            return explain_r(message, code, label=tldr)

	    # Pattern 2 possibility
	    matches = find_matches("__exp__\n"
	                           "print(_var_)")
	    for match in matches:
	        __exp__ = match["__exp__"]
	        _var_ = match["_var_"]
	        submatches = __exp__.find_matches("_var_ = __exp2__")
	        for submatch in submatches:
	            __exp2__ = submatch["__exp2__"]
	            value = __exp2__.value
	            if value in val_list:
	                return explain_r(message, code, label=tldr)
	    return False
	New Code SQL:
		MESSAGE
		LABEL
		TITLE
		FIND "print(__exp__)"
		WHERE "__exp__".value IN val_list
		UNION/OR
		FIND "__exp__\n"
	                           "print(_var_)"
		WITHIN "__exp__" FIND "_var_ = __exp2__"
		WHERE/HAVING "__exp2__".value() IN val_list
		GIVE FEEDBACK


	Concern:
		IMPORTANT DESIGN CONSIDERATION: Should I split the two patterns into two different tests, or try to combine them into 1 test? It seems like I could at least give people the option of running multiple patterns in the same test.
		Also, WHERE again or HAVING?
		Finally, take quotes out of WHERE (and HAVING) clauses or no? Probably take them out.
		Should I use the word UNION, or should I use the word OR?

print_dict_key(keys)
	Old Code:
	    message = ('You\'ve printed the dictionary key <code>"{}"</code> instead of using an extracted value and '
	               'printing it. Use the Dictionary access syntax to print the value associated with a key')
	    code = "dict_k_print"
	    tldr = "Printing key, not value"
	    matches = find_matches("print(__str__)")
	    matches += find_matches("print([__str__])")

	    for match in matches:
	        __str__ = match["__str__"]
	        if __str__.is_ast("Str") and __str__.value in keys:
	            return explain_r(message.format(__str__.value), code, label=tldr)
	    return False
	New Code:
		MESSAGE
		LABEL
		TITLE
		FIND "print(__str__)"
		WHERE "__str__".is_ast("Str") AND "__str__".value IN keys
		GIVE FEEDBACK
		FORMAT MESSAGE USING "__str__".value

var_instead_of_key(keys)
	Old Code:
		message = ("It looks like you are trying to use (<code>{}</code>) as a dictionary key. "
	               "Use the dictionary access syntax to get values from a dictionary")
	    code = "var_as_k"
	    tldr = "Using Variable instead of key"
	    matches = find_matches("_var_")
	    matches += find_matches("[_var_]")
	    for match in matches:
	        _var_ = match["_var_"]
	        if _var_.id in keys:
	            submatch = find_match("_dict_['{}']".format(_var_.id))
	            if submatch is None:
	                return explain_r(message.format(_var_.id), code, label=tldr)
	    return False
	New Code SQL:
		FIND "_var_" OR "[_var_]"
		WHERE "_var_" IN keys
		WITHIN SOURCE_CODE FIND "_dict_['_var_']"
		GIVE NO FEEDBACK
		FORMAT MESSAGE USING "_var_".id 