SQL-Like Specification Language Design


General Flow Design 2
testName(parameters)
MESSAGE
LABEL
TITLE
FIND (FIRST, NOT) "" (,"", ..., "")
(WHERE condition (AND, OR condition))
((WITHIN subpiece/SOURCE_CODE FIND "" (, "", ..., ""))
(WHERE condition (AND, OR condition)))
(AND, OR  find_clause)
GIVE (NO) FEEDBACK (GENTLY)
(FORMAT [MESSAGE, LABEL, TITLE] USING "")



Extended Backus-Naur Form
<spec-lang>			::= [<parameters-part>] <msg-part> <label-part> <title-part> <find-part> <feedback-part>
<parameters-part>	::=	"PARAMETERS" <parameter> {"," <parameter>}
<msg-part>			::= "MESSAGE" <message>
<label-part>		::= "LABEL" <label>
<title-part>		::= "TITLE" <title>
<find-part>			::= <find-each-part> | <normal-find-part>
<find-each-part>	::= <for-each-part> <normal-find-part> "END FOR EACH" ["WITH MERGED FEEDBACK"]
<for-each-part>		::= "FOR EACH" <item-alias> IN <iterable-parameter>
<normal-find-part>	::= "FIND" <code> [<as-part>] [<cut-part>] {"," <code> [<as-part>] [<cut-part>]} [<opt-where-part>] [<opt-within-part>] <if-part>
<as-part>			::= "AS" <alias>
<cut-part>			::= "WITH CUT"
<opt-where-part>	::= WHERE" <boolean-condition> [<opt-extension>]
<boolean-condition>	::= <boolean-code> | <contains-part>
<contains-part>		::= "CONTAINS" ["NO" | "ALL" | "AT LEAST ONE" | "MORE THAN ONE"] <object-contained>
<object-contained>	::= <digit> | <string>
<opt-extension>		::= "AND" <boolean-condition> | "OR" <boolean-condition>
<opt-within-part>	::= "WITHIN" <subfind-part> "FIND" <code> {"," <code>} [<opt-where-part>] [<opt-within-part>]
<if-part>			::= "IF" ["NOT"] "FOUND" <next-part>
<next-part>			::= <find-part> | <feedback-part> 
<feedback-part>		::= "GIVE FEEDBACK" ["GENTLY"] <opt-form-part>
<opt-form-part>		::= "FORMAT" <formtype-part> "USING" <formatter>
<formtype-part>		::= <formtype> {"," <formtype>}
<formtype>			::= "MESSAGE" | "LABEL" | "TITLE"
<formatter>			::= <code>



NOTES 3-5-2020
1. What about different messages for same test/error case? This seems like something that we should look for, based on the conversation.
2. Preconditions for running a given test, such as after 2 tests have come back positive/negative?
3. Put this stuff onto my GitHub. 
4. Make a way to pass in parameters.
5. Make a place for the name of the test.

NOTES 4-1-2020
1. How to extend Backus-Naur Form for easy display of zero-to-many clauses?
2. Consider editing language to allow for more to be done inside the find-part instead of just requiring the feedback part to fall within stuff. Could add flexibility to the language...



Lexer and Parser Work:

FIND-PART: FIND `CODE`(, `CODE`)*
CODE: .+
WHERE-PART: WHERE `CODE` ([AND|OR] `CODE`)*
WITHIN-PART: WITHIN `CODE` FIND-PART

BEGIN: 'BEGIN'
PARAMETERS: 'PARAMETERS'
FIND: 'FIND'
WITHIN: 'WITHIN'
WHERE: 'WHERE'
AND: 'AND'
OR: 'OR'
IF: 'IF'
FOUND: 'FOUND'
WHEN: 'WHEN'
GIVE_FEEDBACK: 'GIVE_FEEDBACK'
END: 'END'


6/8/2020

Goal: develop grammar for simple FIND with WITHIN and WHERE clauses

expr				: begin test_name find_code end
begin 				: 'BEGIN'
test_name			: WORD '(' parameters ')'
find_code			: FIND code_to_find optional_clauses
optional_clauses	: '' |


6/15/2020

EBNF with RegEx for General Flow 3:
<statement>			::= <begin-part> <message-part> <find-part> <end-part>
<begin-part>		::= 'BEGIN' <word>'('<parameter-part>')'
<parameter-part>	::= <word> [','<word>]*
<word>				::= [A-Za-z0-9_-]+
<message-part>		::= 'MESSAGE' <words> 'LABEL' <words> 'TITLE' <words>
<words>				::= ^`[^`]+`$
<find-part>			::= 'FIND' <words> [<optional-parts>]* <if-part>
<optional-parts>	::= <where-part> <within-part> /* <stop-part> */
<where-part>		::= 'WHERE' <words>
<within-part>		::= WITHIN '`'<word>'`' 'FIND' <words>
<if-part>			::= 'IF' [<negation-part>] 'FOUND' ['GENTLY'] 'GIVE' ['NO'] FEEDBACK('<feedback-part>')'
<negation-part>		::= 'NEVER' | 'NOT'
<feedback-part>		::= <words-no-comma> [','<words-no-comma>]*
<words-no-comma>	::= [^,]+
<end-part>			::= 'END'


6/16/2020

/*
 * Parser rules
 */

document				: (statement WHITESPACE+)+ ;
statement				: (beginpart WHITESPACE* messagespart WHITESPACE* findpart WHITESPACE* END | comment);
comment 				: '#' WORDS_NO_HASH '#'
beginpart 				: BEGIN WHITESPACE+ WORD '(' parameterPart ')';
parameterpart 			: WORD (WHITESPACE* COMMA WHITESPACE* WORD)*;
messagespart 			: messagepart WHITESPACE+ labelpart WHITESPACE+ titlepart;
messagepart 			: MESSAGE WHITESPACE+ '`' WORDS '`';
labelpart 				: LABEL WHITESPACE+ '`' WORDS '`';
titlepart 				: TITLE WHITESPACE+ '`' WORDS '`';
findpart 				: FIND WHITESPACE+ '`' CODE '`' (wherepart WHITESPACE+ | withinpart WHITESPACE+)* ifpart;
wherepart 				: WHERE WHITESPACE+ '`' WORDS '`';
withinpart 				: WITHIN WHITESPACE+ '`' WORD '`' WHITESPACE+ FIND WHITESPACE+ '`' CODE '`';
ifpart 					: IF (NEVER | NOT)? FOUND GENTLY? GIVE NO? FEEDBACK '(' feedbackpart ')' ;
feedbackpart 			: WORDS_NO_COMMA WHITESPACE* (COMMA WHITESPACE* WORDS_NO_COMMA)* ;

/*
 * Lexer rules
 */

fragment LOWERCASE 		: [a-z];
fragment UPPERCASE		: [A-Z];
fragment DIGIT 			: [0-9];
fragment COMMA 			: ',';

WORDS 					: ~('`');
WORDS_NO_COMMA 			: ~(',');
WORDS_NO_HASHTAG 		: ~('#');
WORD 					: (LOWERCASE | UPPERCASE | DIGIT | '_' | '-')+ ;
WHITESPACE				: (' ' | '\t' | '\r'? '\n' | '\r'); 
BEGIN 					: 'BEGIN';
MESSAGE 				: 'MESSAGE';
LABEL 					: 'LABEL';
TITLE 					: 'TITLE';
FIND  					: 'FIND';
WHERE  					: 'WHERE';
WITHIN 					: 'WITHIN';
IF 						: 'IF';
NEVER 					: 'NEVER';
NOT 					: 'NOT';
FOUND  					: 'FOUND';
GENTLY 					: 'GENTLY' ;
GIVE 					: 'GIVE' ;
NO 						: 'NO' ;
FEEDBACK 				: 'FEEDBACK' ;
END 					: 'END';


