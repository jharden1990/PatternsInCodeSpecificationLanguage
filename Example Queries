def wrong_list_length_8_2():
            message = "You must have at least three pieces"
            code = "list length_8.2"
            tldr = "List too short"
            matches = find_matches("_list_ = __expr__")
            if matches:
                for match in matches:
                	_list_ = match["_list_"]
                    __expr__ = match["__expr__"]
                    if __expr__.ast_name == "List" and len(__expr__.elts) < 3:
                        return explain_r(message, code, label=tldr)

MESSAGE `You must have at least three pieces`
LABEL `list length_8.2`
TITLE `List too short`
FIND `_list_ = __expr__`
WHERE __expr__ IS OF TYPE LIST AND length(__expr__) < 3
GIVE FEEDBACK





NOTES:
	Multi-line expressions for find part?
	Should we adopt a do-something-nonsensical in case of error, have a silent error log, or something else? Probably have a silent error log for when running on actual student code.
	Better wording for giving feedback when pattern is missing?


list_all_zeros_8_2():
    Old Code:
        message = 'Try seeing what happens when you change the numbers in the list.'
        code = 'default_list_8.2'
        tldr = 'Use different numbers'
        matches = find_matches("_var_ = [__list__]")
        for match in matches:
            __list__ = match['__list__']
            list_node = __list__.parent
            all_num = list_node.find_all("Num")
            all_zeros = True
            for num in all_num:
                if num.n != 0:
                    all_zeros = False
                    break
            if all_zeros:
                return explain_r(message, code, label=tldr)
        return False




print_dict_key(keys)
	Old Code:
	    message = ('You\'ve printed the dictionary key <code>"{}"</code> instead of using an extracted value and '
	               'printing it. Use the Dictionary access syntax to print the value associated with a key')
	    code = "dict_k_print"
	    tldr = "Printing key, not value"
	    matches = find_matches("print(__str__)")
	    matches += find_matches("print([__str__])")

	    for match in matches:
	        __str__ = match["__str__"]
	        if __str__.is_ast("Str") and __str__.value in keys:
	            return explain_r(message.format(__str__.value), code, label=tldr)
	    return False

print_dict_key(keys)
MESSAGE
LABEL
TITLE
FIND print(__str__) OR print([__str__])
WHERE __str__ IS OF TYPE STRING AND __str__.value IN keys
GIVE FEEDBACK FORMAT MESSAGE USING __str__.value, __str__.value2
or...
GIVE FEEDBACK FORMAT MESSAGE USING code = __str__.value AND code2 = __str__.value2

Other idea:
MESSAGE
LABEL
TITLE
FIND print(__str__) AS matches, print([__str__]) AS matches
WHERE __str__ IS OF TYPE STRING AND __str__.value IN keys
IF FOUND ADD TO LIST list_name


Notes:
	What to do when concatenating the lists of matches? How to implement? 
	FIND print(__str__)
	DECLARE __str__ String
	WHERE __str__.value IN keys
	or...
	FIND print(__str__)
	TYPE OF __str__ IS String
	WHERE __str__.value IN keys
	or...
	FIND print(__str__)
	AST __str__ is STRING
	WHERE __str__.value IN keys

	Making design rationale document?



wrong_iteration_body_8_3()
    Old Code:
        message = "The addition of each episode length to the total length is not in the correct place."
        code = "iter_body_8.3"
        tldr = "Accumulation Misplaced"
        match = find_match("for _item_ in _list_:\n"
                           "    sum_length = ___ + ___\n")
        if not match:
            return explain_r(message, code, label=tldr)
        return False




missing_counting_list()
    Old Code:
        message = 'Count the total number of items in the list using iteration.'
        code = "miss_count_list"
        tldr = "Missing Count in Iteration"
        matches = find_matches("for _item_ in ___:\n"
                               "    __expr__")
        if matches:
            for match in matches:
                __expr__ = match["__expr__"]
                submatches = __expr__.find_matches("_sum_ = _sum_ + 1", ) 
                ## IMPORTANT NOTE: purpose of comma here above????? no purpose at this time.
                if submatches:
                    return False
        return explain_r(message, code, label=tldr)

MISSING FIND `for _item_ in ___:\n    __expr__`
WITHIN __expr__ FIND `_sum_ = _sum_ + _var_` AS sum, `_count_ = _count_ + 1` AS count
WITHIN sum 
GIVE FEEDBACK


Notes:
	What about when either of two different patterns results in giving (or not giving) feedback?



Meeting Chat Notes:
Standing questions: How to denote a missing pattern
Denoting giving no feedback, does that mean message is not required? Or if so, what will message have?
A documentation: http://www.cplusplus.com/doc/tutorial/operators/, can you have something like this?
AST node types vs expression types vs variable types. What will be the distinguishing factors?

1. TAKE A LOOK AT THE DOCUMENTATION PROVIDED FOR C++ in the meeting chat. Starting thinking about how to do it for this language.
2. Start working on Design Rationale document.
3. Mull over questions brought up in this meeting. Come back with some decisions.
4. Go back some more advanced SQL queries and see what can be brought over.


MESSAGE
LABEL
TITLE
FIND ``
WHERE
WITHIN
IF FOUND SET X TO TRUE
FIND ...
IF NOT FOUND AND X IS TRUE GIVE FEEDBACK 


Notes 4-16-2020
1. How to include the words "CONDITION" and "RESPONSE"
2. Figure out % of tests covered.