Notes on Successes with (Minor) Assumptions for Specification Language work

Summary of functions, options, property fetches to implement:
	- Need to represent the following functions, options, and property fetches:
		_ .has
			} if __expr__.has(_list_.astNode)
			} .has assumes that left-hand side is an expression node (__expr__, double-underscore), right-hand side has to be either a literal or a name node.
				* CASE literal = equivalent to submatch (literal = ints or floats atm (4-27-2020))
				* CASE name node = finds if that name node is in the expression AST
			} Example implementation: WHERE __expr__ HAS _list_.astNode
			} probably deprecated...
		_ .numeric_logic_check (DON'T IMPLEMENT THIS)
		_ .find_all
			} if len(__expr__sub.find_all("Name")) == 0:
				* WHERE __expr__sub CONTAINS NO VARIABLE
			} if len(__num__.find_all("Num")) > 0:
				* WHERE __num__ CONTAINS AT LEAST 1 NUMBER
				* WHERE ...
			} 
		_ .was_type
			} if _key_.id in keys and not _key_.was_type("StrType"):
			} if data_state(_item_).was_type('list'):
			} elif not data_state(_list_).was_type('list'):
		_ data_state()
			} if data_state(_item_).was_type('list'):
			} if key and data_state(_var_.id):
			} if __str1__.is_ast("Str") and __str2__.is_ast("Str") and data_state(_var_.id):
		_ def_use_error()
			} if data_state(_item_).was_type('list') and def_use_error(_item_):
			} if def_use_error(_item_):
		_ var_check()
			} key = var_check(__str__, keys)
        	  if key:
        	} key = var_check(__str__, unused_keys)
              if key:
            } key = var_check(submatch["__str__"]) ## is __str__ a string? that's what this code is doing.
              if key:
            } value1 = var_check(__str1__, keys)
              value2 = var_check(__str2__, keys)
              if value1 and value2:
		_ uncover_type().type.subtype
			} type_check = uncover_type(_list_, "ListType")
        	  if type_check and str(type_check.type.subtype) == "DictType":
		_ str()
			} str(var_state.type)
			} str(data_state().type.subtype)
			} if type_check and str(type_check.type.subtype) == "DictType":
			} var_state = _var_.get_data_state()
        	  if var_state and str(var_state.type) == "ListType" and str(var_state.type.subtype) == "DictType":
        	} 
		_ list_dict_indices()
			} wrong_keys(unused_keys)
		_ .is_ast("Str")
			} if __str1__.is_ast("Str") and __str2__.is_ast("Str") and data_state(_var_.id):
		_ .value
			} value = __exp__.value
        	  if value in val_list:
        	} if __str__.is_ast("Str") and __str__.value in keys:
        	} wrong_keys(unused_keys):
        	} if __str__.is_ast("Str") and __str__.value == _var_.id:
        	} 
		_ dict_detect()
			} key_comp(keys)
		_ , use_previous = false
			} key_comp(keys): ## Problematic to implement this entire test at this time.
		_ .get_data_state()
			} var_state = _var_.get_data_state()
        	  if var_state and str(var_state.type) == "ListType" and str(var_state.type.subtype) == "DictType":

Minor Assumptions:

	iteration-context.py:
		- where is the TLDR for one of the tests?
			_ perhaps this means that the "GIVE FEEDBACK" piece or the FORMAT part should be changed?
		- if a variable, such as _var_ is used in one pattern and then in a subsequent pattern, does the _var_ from the previous one inform the new pattern's _var_?
			_ I think the answer is yes, from what I remember, but I just wanted to double-check.
		- use of .format(_sum_.id) is different from simply putting in "_sum_" in the requisite pattern? If so, may need to think the affected tests over more.
		- dealing with conditional logic cases where we want to ensure that none of 3+ items are equal in a concise manner...
		- dealing with cases where multiple sub-patterns are being searched for at the same time... can make such patterns work, but performance would be affected.
		- representing .has function in language.
		- any particular reason for not combining the IF statements? wrong_append_problem_atl2_10_5()
		- getting .ast_node.id of a variable
			_ may want to consider adding an optional clause which allows a user to specify what part of an item to fetch? Not the best idea.
		- representing .find_all() function

	instructor_iteration.py:
		- checking astNode of a variable (_item_ and _item_.astNode)?
		- checking astNode of the first instance of a variable (_item_ = match["_item_"][0].astNode vs. _item_ = match["_item_"].astNode)
			_ (_item_ = match["_item_"][0].astNode vs. _item_ = match["_item_"].astNode) are exactly the same.
		- ensuring _item_ from first pattern is same as _item_ from sub-pattern or second pattern?

	dictionaries.py:
		- represent var_check function in language
		- represent .is_ast("Str") in language
		- represent .value fetching in language
		- implementing FIND EACH successfully
		- implement .was_type function
		- How to know when to fetch _var_ = match["_var_"][0] versus match["_var_"].id versus match["_var_"].astNode?
			_ using the [0] is actually deprecated. First instance is fetched automatically unless a different index is specified.
			_ What about adding a FETCH? Is there a way to do this without adding an additional clause?
			_ match["_var_"].id... could make functions smart enough?
			_ Check further on the cases where something other than default behavior is used.
		- need to implement .get_data_state() in language, as well as str(var_state.type) == "SomethingType"
	
Assumptions:

	iteration-context.py:
		- lineno operations (lineno of 1 pattern after lineno of another pattern)
		- Dealing with IF NOT FOUND cases where we only want to give feedback if ALL of the attempts to match the (sub)pattern fail rather than simply the first failure.
			_ Maybe allow IF NOT FOUND for cases where the first time not finding it means giving feedback, and IF NEVER FOUND for cases in which it is NEVER found.
		- Dealing with .numeric_logic_check function and representing cases where the first IF FOUND results in returning false and the message is given IFF never found thing.
			_ Maybe instead of an "IF [NOT] FOUND" statement, or as an additional option, we could use a case statement...
				} CASE IF FOUND: ... CASE IF NEVER FOUND: ... CASE DEFAULT: ...
		- Dealing with .has, .numeric_logic_check, and parentheses for boolean conditions
		- allowing FIND right after "IF [NOT] FOUND", and perhaps handling the case of looking to see if any of 2+ patterns do not exist. Also, "GIVE NO FEEDBACK".

	instructor_iteration.py:
		- how to fetch astNode of a variable (_item_) as well as astNode.id? Also representing data_state() and .was_type() in the language.
		- Allowing IF blocks to have an attached ELSE..., as well as the above concerns.
		- representing .def_use_error() function and first assumption concern from this file.

	dictionaries.py:
		- representing var_check() and data_state()
		- representing uncover_type() and uncover_type().type.subtype and str()
		- representing list_dict_indices() and for index in list_dict_indices(__str__)
		- Need to look into implementing IF STATEMENTS after the END FOR EACH, as well as IF [NOT] FOUND GIVE [NO] FEEDBACK, and into implementing loops after first find...
		- Need to implement either a MERGE FEEDBACK option or add in variables...
		- for the FAIL cases, generally they have a "TRY / EXCEPT" pattern...
		- giving no feedback problem (IF NEVER FOUND, perhaps)
		- implementing dict_detect and use_previous = false
		- for another FAIL, implementing pre-find configs? key_order(keys)
		- for num in range(2), multiple withins treated same...
