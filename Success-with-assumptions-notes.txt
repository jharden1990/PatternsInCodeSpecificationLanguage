Notes on Successes with (Minor) Assumptions for Specification Language work

Summary of functions, options, property fetches to implement:
	- Need to represent the following functions, options, and property fetches:
		_ .has
		_ .numeric_logic_check
		_ .find_all
		_ .was_type
		_ data_state()
		_ def_use_error()
		_ var_check()
		_ uncover_type().type.subtype
		_ str()
			* str(var_state.type)
			* str(data_state().type.subtype)
		_ list_dict_indices()
		_ .is_ast("Str")
		_ .value
		_ dict_detect()
		_ , use_previous = false
		_ .get_data_state()

Minor Assumptions:

	iteration-context.py:
		- where is the TLDR for one of the tests?
			_ perhaps this means that the "GIVE FEEDBACK" piece or the FORMAT part should be changed?
		- if a variable, such as _var_ is used in one pattern and then in a subsequent pattern, does the _var_ from the previous one inform the new pattern's _var_?
			_ I think the answer is yes, from what I remember, but I just wanted to double-check.
		- use of .format(_sum_.id) is different from simply putting in "_sum_" in the requisite pattern? If so, may need to think the affected tests over more.
		- dealing with conditional logic cases where we want to ensure that none of 3+ items are equal in a concise manner...
		- dealing with cases where multiple sub-patterns are being searched for at the same time... can make such patterns work, but performance would be affected.
		- representing .has function in language.
		- any particular reason for not combining the IF statements? wrong_append_problem_atl2_10_5()
		- getting .ast_node.id of a variable
			_ may want to consider adding an optional clause which allows a user to specify what part of an item to fetch?
		- representing .find_all() function

	instructor_iteration.py:
		- checking astNode of a variable (_item_ and _item_.astNode)?
		- checking astNode of the first instance of a variable (_item_ = match["_item_"][0].astNode vs. _item_ = match["_item_"].astNode)
		- ensuring _item_ from first pattern is same as _item_ from sub-pattern or second pattern?

	dictionaries.py:
		- represent var_check function in language
		- represent .is_ast("Str") in language
		- represent .value fetching in language
		- implementing FIND EACH successfully
		- implement .was_type function
		- How to know when to fetch _var_ = match["_var_"][0] versus match["_var_"].id versus match["_var_"].astNode?
		- need to implement .get_data_state() in language, as well as str(var_state.type) == "SomethingType"
	
Assumptions:

	iteration-context.py:
		- lineno operations (lineno of 1 pattern after lineno of another pattern)
		- Dealing with IF NOT FOUND cases where we only want to give feedback if ALL of the attempts to match the (sub)pattern fail rather than simply the first failure.
			_ Maybe allow IF NOT FOUND for cases where the first time not finding it means giving feedback, and IF NEVER FOUND for cases in which it is NEVER found.
		- Dealing with .numeric_logic_check function and representing cases where the first IF FOUND results in returning false and the message is given IFF never found thing.
			_ Maybe instead of an "IF [NOT] FOUND" statement, or as an additional option, we could use a case statement...
				} CASE IF FOUND: ... CASE IF NEVER FOUND: ... CASE DEFAULT: ...
		- Dealing with .has, .numeric_logic_check, and parentheses for boolean conditions
		- allowing FIND right after "IF [NOT] FOUND", and perhaps handling the case of looking to see if any of 2+ patterns do not exist. Also, "GIVE NO FEEDBACK".

	instructor_iteration.py:
		- how to fetch astNode of a variable (_item_) as well as astNode.id? Also representing data_state() and .was_type() in the language.
		- Allowing IF blocks to have an attached ELSE..., as well as the above concerns.
		- representing .def_use_error() function and first assumption concern from this file.

	dictionaries.py:
		- representing var_check() and data_state()
		- representing uncover_type() and uncover_type().type.subtype and str()
		- representing list_dict_indices() and for index in list_dict_indices(__str__)
		- Need to look into implementing IF STATEMENTS after the END FOR EACH, as well as IF [NOT] FOUND GIVE [NO] FEEDBACK, and into implementing loops after first find...
		- Need to implement either a MERGE FEEDBACK option or add in variables...
		- for the FAIL cases, generally they have a "TRY / EXCEPT" pattern...
		- giving no feedback problem (IF NEVER FOUND, perhaps)
		- implementing dict_detect and use_previous = false
		- for another FAIL, implementing pre-find configs? key_order(keys)
		- for num in range(2), multiple withins treated same...
